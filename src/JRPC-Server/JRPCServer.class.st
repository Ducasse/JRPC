"
I am an abstract server for JSON-RPC 2.0.

My subclasses define how to handle JSON-RPC objects coming from a client.

To define that, #sendRequest: message should be overriden by my subclasses.
"
Class {
	#name : #JRPCServer,
	#superclass : #Object,
	#traits : 'JRPCParser',
	#classTraits : 'JRPCParser classTrait',
	#instVars : [
		'namesToHandlersDict'
	],
	#category : #'JRPC-Server'
}

{ #category : #'instance creation' }
JRPCServer class >> http [
	^ JRPCHTTPServer new
]

{ #category : #'instance creation' }
JRPCServer class >> tcp [
	^ JRPCTCPServer new
]

{ #category : #'handlers management' }
JRPCServer >> addHandler: aJRPCHandler [

	namesToHandlersDict
		at: aJRPCHandler procedureName
		ifPresent: [ JRPCNameOfHandlerIsAlreadyTaken signalForHandler: aJRPCHandler ].

	namesToHandlersDict
		at: aJRPCHandler procedureName put: aJRPCHandler.
		
	aJRPCHandler server: self
]

{ #category : #'handlers management' }
JRPCServer >> addHandlerNamed: aString block: aBlock [
	self addHandler: (JRPCBlockHandler new
								procedureName: aString;
								block: aBlock;
								yourself)
]

{ #category : #'handlers management' }
JRPCServer >> addHandlersFromPragmasIn: anObject [
	(Pragma allNamed: #jrpc: in: anObject class)
		do: [ :pragma |
			self addHandler: (JRPCMessageSendHandler new
										receiver: anObject;
										procedureName: pragma arguments first;
										messageSelector: pragma methodSelector;
										yourself) ]
]

{ #category : #checking }
JRPCServer >> checkParamsMatchingForHandler: handler andRequest: aJRPCRequestObject [
	aJRPCRequestObject params
		ifNil: [ 
			handler parametersCount = 0
				ifFalse: [ JRPCInvalidParameters signal ] ].
	
	(aJRPCRequestObject params ifNil: [ #() ]) size = handler parametersCount
		ifFalse: [ JRPCInvalidParameters signal ].
		
	(aJRPCRequestObject params isDictionary
		and: [ ((aJRPCRequestObject params keys union: handler parametersNames) size ~= handler parametersCount) ])
			ifTrue: [ JRPCInvalidParameters signal ]
]

{ #category : #'handling - jrpc' }
JRPCServer >> handleJRPCNotificationObject: aJRPCNotificationObject [
	"A Notification is a Request object without an 'id' member.
	 A Request object that is a Notification signifies the Client's
	 lack of interest in the corresponding Response object, and as
	 such no Response object needs to be returned to the client.
	 The Server MUST NOT reply to a Notification, including those
	 that are within a batch request.

	 Notifications are not confirmable by definition, since they do
	 not have a Response object to be returned. As such, the Client
	 would not be aware of any errors (like e.g. 'Invalid params'
	 'Internal error').
	"
	|response |
	response := self handleJRPCRequestObject: aJRPCNotificationObject.
	
	"In case the request is invalid, an error is returned to the client
	 even though what is described in the above comment.
	 The idea is that, if what was sent by the client is invalid, we are
	 not sure if it was really a notification or if it was a request.
	 Thus, an error is returned.
	"
	(response isError and: [ response isInvalidRequest ])
		ifTrue: [ ^ response ].

	^ JRPCEmptyResponseObject new
]

{ #category : #'handling - jrpc' }
JRPCServer >> handleJRPCRequestObject: aJRPCRequestObject [
	[ | handler result |
		handler := self handlerForName: aJRPCRequestObject method.
		self checkParamsMatchingForHandler: handler andRequest: aJRPCRequestObject.
		result := handler executeWithArguments: aJRPCRequestObject params.
		^ JRPCSuccessResponseObject id: aJRPCRequestObject id result: result
	] on: Error
	do: [ :jrpcError |
		^ aJRPCRequestObject
				convertErrorToResponse: jrpcError ]
]

{ #category : #'handling - json' }
JRPCServer >> handleJSON: aJSONString [
	"Gets aJSONString as input and returns a JSON string.
	 This method will most probably be wrapped by a method from subclasses.
	 These subclasses simply need to get the JSON string from a specific network protocol and transmit the JSON generated by this method to the client who sent the request."
	| jrpcRequestOrNotification jrpcResponse |
	[
		jrpcRequestOrNotification := self parseSupposedJRPCMessageObjectFromString: aJSONString.
		jrpcResponse := jrpcRequestOrNotification beHandledByServer: self
	] on: Error do: [ :error |
		jrpcResponse := error asJRPCResponse
	].
	^ jrpcResponse beConvertedBy: self
]

{ #category : #accessing }
JRPCServer >> handlerForName: anObject [
	anObject isString
		ifFalse: [ JRPCIncorrectJSON signal ].
		
	^ namesToHandlersDict
		at: anObject
		ifAbsent: [ 
			JRPCNonExistentHandler new
				signal: anObject ]
]

{ #category : #initialization }
JRPCServer >> initialize [
	super initialize.
	namesToHandlersDict := Dictionary new
]

{ #category : #testing }
JRPCServer >> isClient [
	"Returns true if the trait is used in the context of a client, false in the context of a server."
	^ false
]

{ #category : #accessing }
JRPCServer >> namesToHandlersDict [
	^ namesToHandlersDict
]

{ #category : #'handlers management' }
JRPCServer >> removeHandlerNamed: aString [
	namesToHandlersDict
		removeKey: aString
		ifAbsent: [ self error: 'Inexistant handler.' ]
]

{ #category : #starting }
JRPCServer >> start [
	"Starts the server.
	 Depends on the transport implementation, to be overrided by subclasses.
	"
	self subclassResponsibility
]

{ #category : #stopping }
JRPCServer >> stop [
	"Stops the server.
	 Depends on the transport implementation, to be overrided by subclasses.
	"
	self subclassResponsibility
]
