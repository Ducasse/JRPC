"
I am an abstract server for JSON-RPC 2.0.

My subclasses define how to handle JSON-RPC objects coming from a client.

To define that, #sendRequest: message should be overriden by my subclasses.
"
Class {
	#name : #JRPCServer,
	#superclass : #Object,
	#traits : 'JRPCParser',
	#classTraits : 'JRPCParser classTrait',
	#instVars : [
		'namesToHandlersDict'
	],
	#category : #'JRPC-Servers'
}

{ #category : #'instance creation' }
JRPCServer class >> http [
	^ JRPCHTTPServer new
]

{ #category : #'handlers management' }
JRPCServer >> addHandlerNamed: aString block: aBlock [
	namesToHandlersDict
		at: aString put: aBlock
]

{ #category : #checking }
JRPCServer >> checkParamsMatchingForHandler: handler andRequest: aJRPCRequestObject [
	aJRPCRequestObject params
		ifNil: [ 
			handler jrpcParametersCount = 0
				ifFalse: [ JRPCInvalidParameters signal ] ].
	
	(aJRPCRequestObject params ifNil: [ #() ]) size = handler jrpcParametersCount
		ifFalse: [ JRPCInvalidParameters signal ].
		
	(aJRPCRequestObject params isDictionary
		and: [ ((aJRPCRequestObject params keys union: handler jrpcParametersNames) size ~= handler jrpcParametersCount) ])
			ifTrue: [ JRPCInvalidParameters signal ]
]

{ #category : #converting }
JRPCServer >> convertJRPCJsonableObjectToJSON: aJRPCJsonableObject [
	^ String streamContents: [ :stream |
		self convertJRPCJsonableObjectToJSON: aJRPCJsonableObject asJRPCJSON on: stream ]
]

{ #category : #'handling - jrpc' }
JRPCServer >> handleJRPCRequestObject: aJRPCRequestObject [
	[ | handler result |
		handler := self handlerForName: aJRPCRequestObject method.
		self checkParamsMatchingForHandler: handler andRequest: aJRPCRequestObject.
		result := handler jrpcExecuteWithParameters: aJRPCRequestObject params.
		^ JRPCSuccessResponseObject id: aJRPCRequestObject id result: result
	] on: JRPCError
	do: [ :jrpcError |
		^ aJRPCRequestObject
				convertErrorToResponse: jrpcError ]
]

{ #category : #'handling - json' }
JRPCServer >> handleJSON: aJSONString [
	"Gets aJSONString as input and returns a JSON string.
	 This method will most probably be wrapped by a method from subclasses.
	 These subclasses simply need to get the JSON string from a specific network protocol and transmit the JSON generated by this method to the client who sent the request."
	| jrpcRequestOrNotification jrpcResponse |
	[
		jrpcRequestOrNotification := self parseSupposedJRPCMessageObjectFromString: aJSONString.
		jrpcResponse := jrpcRequestOrNotification beHandledByServer: self
	] on: STONReaderError, JRPCIncorrectJSON do: [ :error |
		jrpcResponse := error asJRPCResponse
	].
	^ jrpcResponse beConvertedBy: self
]

{ #category : #accessing }
JRPCServer >> handlerForName: anObject [
	anObject isString
		ifFalse: [ JRPCIncorrectJSON signal ].
		
	^ namesToHandlersDict
		at: anObject
		ifAbsent: [ 
			JRPCNonExistentHandler new
				signal: anObject ]
]

{ #category : #initialization }
JRPCServer >> initialize [
	super initialize.
	namesToHandlersDict := Dictionary new
]

{ #category : #testing }
JRPCServer >> isClient [
	"Returns true if the trait is used in the context of a client, false in the context of a server."
	^ false
]

{ #category : #accessing }
JRPCServer >> namesToHandlersDict [
	^ namesToHandlersDict
]

{ #category : #'handlers management' }
JRPCServer >> removeHandlerNamed: aString [
	namesToHandlersDict
		removeKey: aString
		ifAbsent: [ self error: 'Inexistant handler.' ]
]

{ #category : #starting }
JRPCServer >> start [
	"Starts the server.
	 Depends on the transport implementation, to be overrided by subclasses.
	"
	self subclassResponsibility
]

{ #category : #stopping }
JRPCServer >> stop [
	"Stops the server.
	 Depends on the transport implementation, to be overrided by subclasses.
	"
	self subclassResponsibility
]
