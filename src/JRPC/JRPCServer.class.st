"
I am an abstract server for JSON-RPC 2.0.

My subclasses define how to handle JSON-RPC objects coming from a client.

To define that, #sendRequest: message should be overriden by my subclasses.
"
Class {
	#name : #JRPCServer,
	#superclass : #Object,
	#traits : 'JRPCParser',
	#classTraits : 'JRPCParser classTrait',
	#instVars : [
		'namesToHandlersDict'
	],
	#category : #'JRPC-Servers'
}

{ #category : #'handlers management' }
JRPCServer >> addHandlerNamed: aString block: aBlock [
	namesToHandlersDict
		at: aString put: aBlock
]

{ #category : #checking }
JRPCServer >> checkParamsMatchingForHandler: handler andRequest: aJRPCRequestObject [
	aJRPCRequestObject params
		ifNil: [ 
			handler jrpcParametersCount = 0
				ifFalse: [ JRPCInvalidParameters signal ] ].
	
	(aJRPCRequestObject params ifNil: [ #() ]) size = handler jrpcParametersCount
		ifFalse: [ JRPCInvalidParameters signal ].
		
	(aJRPCRequestObject params isDictionary
		and: [ ((aJRPCRequestObject params keys union: handler jrpcParametersNames) size ~= handler jrpcParametersCount) ])
			ifTrue: [ JRPCInvalidParameters signal ]
]

{ #category : #'handling - jrpc' }
JRPCServer >> handleJRPCRequestObject: aJRPCRequestObject [
	[ | handler result |
		handler := self handlerForName: aJRPCRequestObject method.
		self checkParamsMatchingForHandler: handler andRequest: aJRPCRequestObject.
		result := handler jrpcExecuteWithParameters: aJRPCRequestObject params.
		^ JRPCSuccessResponseObject id: aJRPCRequestObject id result: result
	] on: JRPCError
	do: [ :jrpcError |
		^ jrpcError asJRPCResponseWithId: aJRPCRequestObject id ]
]

{ #category : #'handling - json' }
JRPCServer >> handleJSON: aJSONString [
	"Gets aJSONString as input and returns a JSON string.
	 This method will most probably be wrapped by a method from subclasses.
	 These subclasses simply need to get the JSON string from a specific network protocol and transmit the JSON generated by this method to the client who sent the request."
	| jrpcRequest jrpcResponse |
	jrpcRequest := self parseSupposedJRPCMessageObjectFromString: aJSONString.
	jrpcResponse := self handleJRPCRequestObject: jrpcRequest.
	^ self convertJRPCDictionaryObjectToJSON: jrpcResponse asJRPCJSON
]

{ #category : #accessing }
JRPCServer >> handlerForName: aString [
	^ namesToHandlersDict
		at: aString
		ifAbsent: [ 
			JRPCNonExistentHandler new
				handlerName: aString;
				signal: aString ]
]

{ #category : #initialization }
JRPCServer >> initialize [
	super initialize.
	namesToHandlersDict := Dictionary new
]

{ #category : #accessing }
JRPCServer >> namesToHandlersDict [
	^ namesToHandlersDict
]

{ #category : #parsing }
JRPCServer >> parseSupposedJRPCMessageObjectFromStream: aStream [
	"Try to parse a JRPCDictionaryObject that should be held by aStream
	 (but we're not sure at this point).
	 Generate understandable errors if there is a problem."
	| dictionary |
	dictionary := STONJSON fromStream: aStream.
	^ (JRPCMessageObject classToInstantiateForDictionary: dictionary)
			fromJRPCJSONObject: dictionary
]

{ #category : #'handlers management' }
JRPCServer >> removeHandlerNamed: aString [
	namesToHandlersDict
		removeKey: aString
		ifAbsent: [ self error: 'Inexistant handler.' ]
]

{ #category : #starting }
JRPCServer >> start [
	"Starts the server.
	 Depends on the transport implementation, to be overrided by subclasses.
	"
	self subclassResponsibility
]

{ #category : #stopping }
JRPCServer >> stop [
	"Stops the server.
	 Depends on the transport implementation, to be overrided by subclasses.
	"
	self subclassResponsibility
]
